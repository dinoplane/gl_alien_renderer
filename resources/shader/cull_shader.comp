#version 460 core
layout (local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

struct Plane
{
    vec4 normalAndDistance;
};

struct Frustum
{
    Plane top;
    Plane bottom;

    Plane right;
    Plane left;

    Plane far;
    Plane near;
};

struct SphereAABB
{
    vec4 centerAndRadius;
};


// Input --------------------------------------
// bounding volumes
layout(binding = 0, std430) readonly buffer boundingVolBuf {
    SphereAABB boundingVolumes[];
};

// bounding volumes matrices
layout(binding = 4, std430) readonly buffer instModelMatBuf {
    mat4 worldFromModel[];
};

layout (binding = 6, std140) uniform frustumCullData {
    Frustum frustum;
    uint instCount; // This is the number of instances
};

// Output -------------------------------------
layout(binding = 5, std430) writeonly buffer instMeshRenderedBuf {
    bool meshIsRendered[];
};


// Helper functions ----------------------------
float GetSignedDistanceToPlane(vec3 point, Plane plane)
{
    return dot(plane.normalAndDistance.xyz, point) - plane.normalAndDistance.w;
}

bool IsSphereOnOrForwardPlane( SphereAABB sphere, Plane plane )
{
    return GetSignedDistanceToPlane( sphere.centerAndRadius.xyz, plane ) > -sphere.centerAndRadius.w;
}


// This can definitely be optimized
bool IsSphereOnFrustum ( SphereAABB sphere, Frustum frustum )
{
    const vec4 center = vec4( sphere.centerAndRadius.xyz, 1.0 );
    const vec4 surfacePoint =  center + vec4( sphere.centerAndRadius.w, 0.0, 0.0, 0.0 );

    // Transform sphere to world space
    const vec4 newCenter = worldFromModel[gl_GlobalInvocationID.x] * center;
    const vec4 newSurfacePoint = worldFromModel[gl_GlobalInvocationID.x] * surfacePoint;
    const float newRadius = length( newSurfacePoint - newCenter );

    const SphereAABB newSphere = SphereAABB( vec4(newCenter.xyz, newRadius) );

    return IsSphereOnOrForwardPlane( newSphere, frustum.near ) &&
           IsSphereOnOrForwardPlane( newSphere, frustum.far ) &&
           IsSphereOnOrForwardPlane( newSphere, frustum.left ) &&
           IsSphereOnOrForwardPlane( newSphere, frustum.right ) &&
           IsSphereOnOrForwardPlane( newSphere, frustum.top ) &&
           IsSphereOnOrForwardPlane( newSphere, frustum.bottom );
}

void main()
{
    uint index = gl_GlobalInvocationID.x;
    if (index < instCount)
    {
        SphereAABB sphere = boundingVolumes[index];
        meshIsRendered[index] = IsSphereOnFrustum(sphere, frustum);
    }else {
        meshIsRendered[index] = false;
    }
}

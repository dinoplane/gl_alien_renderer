#version 460 core
layout (local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

struct Plane
{
    vec4 normalAndDistance;
};

struct Frustum
{
    Plane top;
    Plane bottom;

    Plane right;
    Plane left;

    Plane far;
    Plane near;
};

struct SphereAABB
{
    vec4 centerAndRadius;
};


// Input --------------------------------------
// bounding volumes
layout(binding = 0, std430) readonly buffer ssbo0 {
    SphereAABB boundingVolumes[];
};

// bounding volumes matrices
layout(binding = 1, std430) readonly buffer ssbo1 {
    mat4 worldFromModel[];
};

uniform Frustum frustum;

// Output -------------------------------------
layout(binding = 2, std430) writeonly buffer ssbo2 {
    bool meshIsRendered[];
};


// Helper functions ----------------------------
float GetSignedDistanceToPlane(vec3 point, Plane plane)
{
    return dot(normalAndDistance.xyz, point) - normalAndDistance.w;
}

bool IsSphereOnOrForwardPlane( SphereAABB sphere, Plane plane )
{
    return GetSignedDistanceToPlane( sphere.centerAndRadius.xyz, plane ) > -sphere.centerAndRadius.w;
}


// This can definitely be optimized
bool IsSphereOnFrustum ( SphereAABB sphere, Frustum frustum )
{
    const vec4 center = vec4( sphere.centerAndRadius.xyz, 1.0 );
    const vec4 surfacePoint =  center + vec4( sphere.centerAndRadius.w, 0.0, 0.0, 0.0 );

    // Transform sphere to world space
    const vec4 newCenter = worldFromModel[gl_GlobalInvocationID.x] * center;
    const vec4 newSurfacePoint = worldFromModel[gl_GlobalInvocationID.x] * surfacePoint;
    const float newRadius = length( newSurfacePoint - newCenter );

    const SphereAABB newSphere = SphereAABB( newCenter, newRadius );

    return IsSphereOnOrForwardPlane( newSphere, frustum.near ) &&
           IsSphereOnOrForwardPlane( newSphere, frustum.far ) &&
           IsSphereOnOrForwardPlane( newSphere, frustum.left ) &&
           IsSphereOnOrForwardPlane( newSphere, frustum.right ) &&
           IsSphereOnOrForwardPlane( newSphere, frustum.top ) &&
           IsSphereOnOrForwardPlane( newSphere, frustum.bottom );
}

void main()
{
    uint index = gl_GlobalInvocationID.x;
    SphereAABB sphere = boundingVolumes[index];
    meshIsRendered[index] = IsSphereOnFrustum(sphere, frustum);
}
